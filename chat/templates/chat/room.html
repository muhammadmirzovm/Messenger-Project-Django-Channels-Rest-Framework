<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Room: {{ room.name }}</title>
</head>
<body>
  {% if user.is_authenticated %}
    <p>Hello, <b>{{ user.username }}</b> — <a href="{% url 'logout' %}">Logout</a></p>
  {% else %}
    <p><a href="{% url 'login' %}?next={{ request.path }}">Login</a> |
       <a href="{% url 'signup' %}">Sign up</a></p>
  {% endif %}

  <p><a href="{% url 'index' %}">← Back to rooms</a></p>
  <h2>Room: {{ room.name }}</h2>

  <!-- Online in this room -->
  <h3>Online in this room</h3>
  <ul id="room-online"><li>Loading…</li></ul>

  <h3>Messages</h3>
  <ul id="messages">
    {% for m in messages %}
      <li>
        <b>{{ m.user.username }}:</b>
        {{ m.text }}
        <small>({{ m.created_at|date:"H:i" }})</small>
      </li>
    {% empty %}
      <li>No messages yet</li>
    {% endfor %}
  </ul>

  <input id="chat-message-input" type="text" placeholder="Type message..." {% if not user.is_authenticated %}disabled{% endif %}>
  <button id="chat-message-submit" {% if not user.is_authenticated %}disabled{% endif %}>Send</button>

  <!-- CHAT WS -->
  <script>
    // ✅ Safe for linter:
    const roomId    = Number('{{ room.id|escapejs }}');
    const IS_AUTH   = '{{ user.is_authenticated|yesno:"true,false" }}' === 'true';
    const requestId = Math.random().toString(36).slice(2);

    // DCRF chat websocket (matches your router)
    const chatURL = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws/chat/room/";
    const socket = new WebSocket(chatURL);

    function send(obj) { socket.send(JSON.stringify(obj)); }

    function append(username, text) {
      const li = document.createElement("li");
      li.innerHTML = "<b>" + username + ":</b> " + text;
      document.querySelector("#messages").appendChild(li);
    }

    socket.onopen = function () {
      send({ action: "join_room", pk: roomId, request_id: requestId });
    };

    socket.onmessage = function (e) {
      const data = JSON.parse(e.data);

      // DCRF observer payload
      if (data && data.data && data.data.text) {
        const m = data.data;
        append(m.user.username, m.text);
      }

      // server error responses
      if (data && data.detail) {
        append("server", data.detail);
      }
    };

    document.getElementById("chat-message-submit").onclick = function () {
      const input = document.getElementById("chat-message-input");
      const text = input.value.trim();
      if (!text) return;
      send({ action: "create_message", room: roomId, message: text });
      input.value = "";
    };

    document.getElementById("chat-message-input").addEventListener("keyup", function (e) {
      if (e.key === "Enter") {
        document.getElementById("chat-message-submit").click();
      }
    });
  </script>

  <!-- ROOM PRESENCE WS -->
  <script>
    (function(){
      if (!IS_AUTH) {
        document.getElementById("room-online").innerHTML = "<li>Login to see who is online</li>";
        return;
      }

      const presURL = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws/room/" + roomId + "/presence/";
      const psock = new WebSocket(presURL);
      let every = 20, timer = null;

      function renderFromAPI(){
        fetch("/api/room/" + roomId + "/online/")
          .then(r=>r.json())
          .then(d=>{
            const list = (d.online || []).map(u=>"<li>"+u.username+"</li>").join("");
            document.getElementById("room-online").innerHTML = list || "<li>No one online in this room</li>";
          })
          .catch(()=>{
            document.getElementById("room-online").innerHTML = "<li>(offline)</li>";
          });
      }

      function startHB(){
        if (timer) clearInterval(timer);
        timer = setInterval(function(){
          if (psock.readyState === 1) psock.send(JSON.stringify({type:"heartbeat"}));
        }, every * 1000);
      }

      psock.onmessage = function(e){
        const msg = JSON.parse(e.data);
        if (msg.type === "room_online"){
          every = msg.heartbeat_every || every;
          startHB();
          renderFromAPI();
        } else if (msg.type === "presence_event"){
          renderFromAPI();
        }
      };

      psock.onclose = function(){ if (timer) clearInterval(timer); };
    })();
  </script>
</body>
</html>
